<?php if(!defined("SITE_ROOT")) die();




function connect ($server, $port = 110, $ssl = false) 
    { 
        global $buffer, $error; 
		
		
        //    Opens a socket to the specified server. Unless overridden, 
        //    port defaults to 110. Returns true on success, false on fail 

       $server = ($ssl) ? "ssl://".$server : $server;
        //if(!$fp = fsockopen($e_server, $port, &$errno, &$errstr)) 
		if(!$fp = fsockopen($server, $port , $errno, $errstr)) 
        { 
            $error = "Error connecting to server [$errno] [$errstr]"; 
            return false; 
        } 

        stream_set_blocking($fp,true); 
        update_timer(); 
        $reply = fgets($fp,$buffer); 
        $reply = strip_clf($reply); 
        if(!is_ok($reply)) 
        { 
            $error = "Error connecting to server [$reply]"; 
            return false; 
        } 

        $BANNER = parse_banner($reply); 
        $RFC1939 = noop($fp); 
        if($RFC1939) 
        { 
            $error = "Error connecting to server: premature NOOP OK, NOT an RFC 1939 Compliant server"; 
            quit($fp); 
            return false; 
        } 
        return $fp; 
    }// end function 

function noop ($fp) 
    { 

        $cmd = "NOOP"; 
        $reply = send_cmd($cmd, $fp); 
        if(!is_ok($reply)) 
        { 
            return false; 
        } 
        return true; 
    }// end function 

function user ($user, $fp) 
    { 
	global $error;
        // Sends the USER command, returns true or false 

        if(empty($user)) 
        { 
            $error = "No email user ID submitted"; 
            return false; 
        } 

        $reply = send_cmd("USER $user", $fp); 
        if(!is_ok($reply)) 
        { 
            $error = "Mail user: Error [$reply]"; 
            return false; 
        } 
        return true; 
    }// end function 

function pass ($pass, $fp) 
    { 
	global $error;
        // Sends the PASS command, returns # of msgs in mailbox, 
        // returns false (undef) on Auth failure 

        if(empty($pass)) 
        { 
            $error = "No password submitted"; 
            return false; 
        } 

        $reply = send_cmd("PASS $pass", $fp); 
        if(!is_ok($reply)) 
        { 
            $error = "Mail password incorrect [$reply]"; 
            quit($fp); 
            return false; 
        } 
        
       
        $RFC1939 = noop($fp); 
        if(!$RFC1939) 
        { 
            $error = "Server not RFC 1939 compliant"; 
            quit($fp); 
            return false; 
        } 
        return true; 
    }// end function 

function login ($login = "", $pass = "", $fp) 
    { 
	global $error;
        // Sends both user and pass. Returns # of msgs in mailbox or 
        // false on failure (or -1, if the error occurs while getting 
        // the number of messages.) 

        if(!user($login, $fp)) 
        { 
            //    Preserve the error generated by user() 
            return false; 
        } 

        if(!pass($pass, $fp))
        {
            //    Preserve the error generated by last() and pass() 
			
            return false;
        } 
		
        return true; 
    }// end function 

function top ($msgNum, $numLines = "0", $fp) 
    { 
	global $error;
        //    Gets the header and first $numLines of the msg body 
        //    returns data in an array with each returned line being 
        //    an array element. If $numLines is empty, returns 
        //    only the header information, and none of the body. 


        update_timer(); 


        $buffer = 512; 
        $cmd = "TOP $msgNum $numLines"; 
        fwrite($fp, "TOP $msgNum $numLines\r\n"); 
        $reply = fgets($fp, $buffer); 
        $reply = strip_clf($reply); 
        if(defined('DEBUG')) { @error_log("POP3 SEND [$cmd] GOT [$reply]",0); } 
        if(!is_ok($reply)) 
        { 
            $error = "POP3 top: Error [$reply]"; 
            return false; 
        } 

        $c = 0; 
        $MsgArray = array(); 

        $line = fgets($fp,$buffer); 
        while ( !preg_match("#^\.\r\n#",$line)) 
        { 
            $MsgArray[$c] = $line; 
            $c++; 
            $line = fgets($fp,$buffer); 
            if(empty($line))    { break; } 
        } 

        return $MsgArray; 
    }// end function 

function pop_list ($msgNum = "", $fp) 
    { 
	global $error, $count;
        //    If called with an argument, returns that msgs' size in octets 
        //    No argument returns an associative array of undeleted 
        //    msg numbers and their sizes in octets 
                global $buffer; 

        $Total = $count; 
        if( (!$Total) or ($Total == -1) ) 
        { 
            return false; 
        } 
        if($Total == 0) 
        { 
            return array("0","0"); 
            // return -1;    // mailbox empty 
        } 

        $update_timer(); 

        if(!empty($msgNum)) 
        { 
            $cmd = "LIST $msgNum"; 
            fwrite($fp,"$cmd\r\n"); 
            $reply = fgets($fp,$buffer); 
            $reply = strip_clf($reply); 
            if(!is_ok($reply)) 
            { 
                $error = "POP3 pop_list: Error [$reply]"; 
                return false; 
            } 
            list($junk,$num,$size) = explode(" ",$reply); 
            return $size; 
        } 
        $cmd = "LIST"; 
        $reply = $send_cmd($cmd, $fp); 
        if(!is_ok($reply)) 
        { 
            $reply = strip_clf($reply); 
            $error = "POP3 pop_list: Error [$reply]"; 
            return false; 
        } 
        $MsgArray = array(); 
        $MsgArray[0] = $Total; 
        for($msgC=1;$msgC <= $Total; $msgC++) 
        { 
            if($msgC > $Total) { break; } 
            $line = fgets($fp,$buffer); 
            $line = strip_clf($line); 
            if(preg_match("#^\.#",$line)) 
            { 
                $error = "POP3 pop_list: Premature end of list"; 
                return false; 
            } 
            list($thisMsg,$msgSize) = explode(" ",$line); 
            settype($thisMsg,"integer"); 
            if($thisMsg != $msgC) 
            { 
                $MsgArray[$msgC] = "deleted"; 
            } 
            else 
            { 
                $MsgArray[$msgC] = $msgSize; 
            } 
        } 
        return $MsgArray; 
    }// end function 

function get ($msgNum, $fp) 
    { 
	global $error;
        //    Retrieve the specified msg number. Returns an array 
        //    where each line of the msg is an array element. 

        global $buffer; 
        update_timer(); 

        $buffer = $buffer; 
        $cmd = "RETR $msgNum"; 

        $reply = send_cmd($cmd, $fp); 

        if(!is_ok($reply)) 
        { 
            $error = "POP3 get: Error [$reply]"; 
            return false; 
        } 

        $c = 0; 
        $MsgArray = array(); 

        $line = fgets($fp,$buffer); 
        while ( !preg_match("#^\.\r\n#",$line)) 
        { 
            $MsgArray[$c] = $line; 
            $c++; 
            $line = fgets($fp,$buffer); 
            if(empty($line))    { break; }
        } 
        return $MsgArray; 
    }// end function 

function last($type = "count", $fp) 
    { 
	global $error;
        //    Returns the highest msg number in the mailbox. 
        //    returns -1 on error, 0+ on success, if type != count 
        //    results in a popstat() call (2 element array returned) 

        $last = -1; 

        $reply = send_cmd("STAT", $fp); 
        if(!is_ok($reply)) 
        { 
            $error = "POP3 last: error [$reply]"; 
            return $last; 
        } 

        $Vars = explode(" ",$reply); 
        $c = $Vars[1]; 
        $size = $Vars[2]; 
        settype($c,"integer"); 
        settype($size,"integer"); 
        if($type != "count") 
        { 

            return array($c,$size); 
        } 
        return $c; 
    }// end function 

function resets($fp) 
    { 
	global $error;
        //    Resets the status of the remote server. This includes 
        //    resetting the status of ALL msgs to not be deleted. 
        //    This method automatically closes the connection to the server. 


        $reply = send_cmd("RSET", $fp); 
        if(!is_ok($reply)) 
        { 
            //    The POP3 RSET command -never- gives a -ERR 
            //    response - if it ever does, something truely 
            //    wild is going on. 

            $error = "POP3 reset: Error [$reply]"; 
        } 
        quit($fp); 
        return true; 
    }// end function 

function send_cmd ( $cmd, $fp ) 
    { 
	global $error, $buffer;
        //    Sends a user defined command string to the 
        //    POP server and returns the results. Useful for 
        //    non-compliant or custom POP servers. 
        //    Do NOT include the \r\n as part of your command 
        //    string - it will be appended automatically. 

        //    The return value is a standard fgets() call, which 
        //    will read up to $buffer bytes of data, until it 
        //    encounters a new line, or EOF, whichever happens first. 

        //    This method works best if $cmd responds with only 
        //    one line of data. 
        if(!isset($fp)) 
        { 
            $error = "POP3 send_cmd: No connection to server"; 
            return false; 
        } 

        if(empty($cmd)) 
        { 
            $error = "POP3 send_cmd: Empty command string"; 
            return ""; 
        } 

        update_timer();
        fwrite($fp,"$cmd\r\n"); 
        $reply = fgets($fp,$buffer); 
        $reply = strip_clf($reply); 
        return $reply; 
    }// end function 

function quit($fp) 
    { 
	global $error;
        //    Closes the connection to the POP3 server, deleting 
        //    any msgs marked as deleted. 
        global $buffer; 

        $cmd = "QUIT"; 
        fwrite($fp,"$cmd\r\n"); 
        $reply = fgets($fp,$buffer); 
        $reply = strip_clf($reply); 
        fclose($fp); 
        return true; 
    }// end function 


function is_ok ($cmd = "") 
    { 
	
        //    Return true or false on +OK or -ERR 

        if(empty($cmd))                 { return false; } 
        if ( preg_match ("#^\+OK#", $cmd ) )    { return true; } 
        return false; 
    }// end function 

function strip_clf ($text = "") 
    { 
        // Strips \r\n from server responses 

        if(empty($text)) { return $text; } 
        $stripped = preg_replace("#\r#","",$text); 
        $stripped = preg_replace("#\n#","",$stripped); 
        return $stripped; 
    }// end function 

function parse_banner ( $server_text ) 
    { 
        $outside = true; 
        $banner = ""; 
        $length = strlen($server_text); 
        for($count =0; $count < $length; $count++) 
        { 
            $digit = substr($server_text,$count,1); 
            if(!empty($digit)) 
            { 
                if( (!$outside) and ($digit != '<') and ($digit != '>') ) 
                { 
                    $banner .= $digit; 
                } 
                if ($digit == '<') 
                { 
                    $outside = false; 
                } 
                if($digit == '>') 
                { 
                    $outside = true; 
                } 
            } 
        } 
        $banner = strip_clf($banner);    // Just in case 
        return "<$banner>"; 
    }// end function 

function popstat () 
    { 
        //    Returns an array of 2 elements. The number of undeleted 
        //    msgs in the mailbox, and the size of the mbox in octets. 

        $PopArray = last("array"); 

        if($PopArray == -1) { return false; } 

        if( (!$PopArray) or (empty($PopArray)) ) 
        { 
            return false; 
        } 
        return $PopArray; 
    }// end function 

function uidl ($msgNum = "", $fp) 
    { 
        //    Returns the UIDL of the msg specified. If called with 
        //    no arguments, returns an associative array where each 
        //    undeleted msg num is a key, and the msg's uidl is the element 
        //    Array element 0 will contain the total number of msgs 

        global $buffer, $count; 

        if($msgNum!="") 
        { 
            $cmd = "UIDL ".$msgNum; 
            $reply = send_cmd($cmd, $fp); 
            if(!is_ok($reply)) 
            { 
                $error = "POP3 uidl: Error [$reply]"; 
                return false; 
            } 
            list ($ok,$num,$myUidl) = explode(" ",$reply); 
            return $myUidl; 
        } 
        else 
        { 
            //update_timer(); 

            $UIDLArray = array(); 
            $Total = $count; 
            $UIDLArray[0] = $Total; 

            if ($Total < 1) 
            { 
                return $UIDLArray; 
            } 
            $cmd = "UIDL"; 
            fwrite($fp, "UIDL\r\n"); 
            $reply = fgets($fp, $buffer); 
            $reply = strip_clf($reply); 

            if(!is_ok($reply)) 
            { 
                $error = "POP3 uidl: Error [$reply]"; 
                return false; 
            } 

            $line = ""; 
            $count = 1; 
            $line = fgets($fp,$buffer); 
            while ( !preg_match("#^\.\r\n#",$line)) 
            { 
                if(preg_match("#^\.\r\n#",$line)) 
                { 
                    break; 
                } 
                list ($msg,$msgUidl) = explode(" ",$line); 
                $msgUidl = strip_clf($msgUidl); 
                if($count == $msg) 
                { 
                    $UIDLArray[$msg] = $msgUidl; 
                } 
                else 
                { 
                    $UIDLArray[$count] = "deleted"; 
                } 
                $count++; 
                $line = fgets($fp,$buffer); 
            } 
        } 
       return $UIDLArray; 
    }// end function 

function delete ($msgNum = "", $fp) 
    { 
	global $error;
        //    Flags a specified msg as deleted. The msg will not 
        //    be deleted until a quit() method is called. 

        if(empty($msgNum)) 
        { 
            $error = "POP3 delete: No msg number submitted"; 
            return false; 
        } 
        $reply = send_cmd("DELE $msgNum", $fp); 
        if(!is_ok($reply)) 
        { 
            $error = "POP3 delete: Command failed [$reply]"; 
            return false; 
        } 
        return true; 
    }// end function 


function update_timer() 
    { 
     global $timeout; 
     set_time_limit($timeout); 

    } 
?>